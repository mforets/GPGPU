var documenterSearchIndex = {"docs":
[{"location":"man/cipher/","page":"Affine cipher","title":"Affine cipher","text":"DocTestSetup  = quote\n    using GPGPU\nend\nCurrentModule = GPGPU","category":"page"},{"location":"man/cipher/#Affine-cipher","page":"Affine cipher","title":"Affine cipher","text":"","category":"section"},{"location":"man/cipher/","page":"Affine cipher","title":"Affine cipher","text":"In this problem we consider an affine cipher, which is a special case of a monoalphabetic substitution cipher, where each letter in an alphabet is mapped to its numeric equivalent, encrypted with a simple mathematical function using modular artihmetic.","category":"page"},{"location":"man/cipher/#Problem-definition","page":"Affine cipher","title":"Problem definition","text":"","category":"section"},{"location":"man/cipher/","page":"Affine cipher","title":"Affine cipher","text":"The encryption function has the form","category":"page"},{"location":"man/cipher/","page":"Affine cipher","title":"Affine cipher","text":"E(x) = (Ax + B) mod M","category":"page"},{"location":"man/cipher/","page":"Affine cipher","title":"Affine cipher","text":"and converted back to a letter. Here A and B are the encryption keys and M is the size of the alphabet. In this problem we consider an affine cipher with M = 256, and encryption keys A = 15 and B=27. Decryption is always possible provided that A and M are co-prime (i.e. they have only 1 as their common factor), and the decryption function is:","category":"page"},{"location":"man/cipher/","page":"Affine cipher","title":"Affine cipher","text":"D(x) = A^-1(x - B) mod M","category":"page"},{"location":"man/cipher/","page":"Affine cipher","title":"Affine cipher","text":"where A^-1 is the multiplicative inverse of A modulo M, i.e. satisfies the equation 1 = AA^-1 mod M.","category":"page"},{"location":"man/cipher/","page":"Affine cipher","title":"Affine cipher","text":"Since each letter can be encrypted and decrypted independently, we can use the GPU to decrypt a certain text in parallel.","category":"page"},{"location":"man/cipher/#Serial-implementation-(CPU)","page":"Affine cipher","title":"Serial implementation (CPU)","text":"","category":"section"},{"location":"man/cipher/#Encryption-function","page":"Affine cipher","title":"Encryption function","text":"","category":"section"},{"location":"man/cipher/","page":"Affine cipher","title":"Affine cipher","text":"The following C function is used to compute the module between two integers a and b, guaranteeting that the result is always nonnegative.","category":"page"},{"location":"man/cipher/","page":"Affine cipher","title":"Affine cipher","text":"__device__ int modulo(int a, int b){\n\tint r = a % b;\n\tr = (r < 0) ? r + b : r;\n\treturn r;\n}","category":"page"},{"location":"man/cipher/","page":"Affine cipher","title":"Affine cipher","text":"The implementation in Julia is:","category":"page"},{"location":"man/cipher/","page":"Affine cipher","title":"Affine cipher","text":"function _mod(a, b)\n    r = a % b\n    r = (r < 0) ? r + b : r\n    return r\nend","category":"page"},{"location":"man/cipher/#Decryption-function","page":"Affine cipher","title":"Decryption function","text":"","category":"section"},{"location":"man/cipher/","page":"Affine cipher","title":"Affine cipher","text":"function decrypt(message::Vector{<:Integer}, Ainv, B, M)\n    n = length(message)\n    out = similar(message)\n    \n    for i in 1:n\n        out[i] = decrypt(message[i], Ainv, B, M)\n    end\n    return out\nend\n\nfunction decrypt(x::Integer, Ainv, B, M)\n    y = Ainv * (x - B)\n    return _mod(y, M)\nend","category":"page"},{"location":"man/cipher/","page":"Affine cipher","title":"Affine cipher","text":"For instance,","category":"page"},{"location":"man/cipher/","page":"Affine cipher","title":"Affine cipher","text":"message = [1, 2, 3]","category":"page"},{"location":"man/cipher/","page":"Affine cipher","title":"Affine cipher","text":"julia> A = 15;\n\njulia> Ainv = -17 # inverse of A modulo M\n\njulia> B = 27\n\njulia> M = 256;\n\njulia> decrypt(message, A, B, M)\n3-element Vector{Int64}:\n 122\n 137\n 152","category":"page"},{"location":"man/cipher/#Data","page":"Affine cipher","title":"Data","text":"","category":"section"},{"location":"man/cipher/","page":"Affine cipher","title":"Affine cipher","text":"data = \"secreto.txt\"\n\nfunction _open(path)\n    file = open(path, \"r\")\n    text = Vector{UInt8}()\n\n    while !eof(file)\n        i = read(file, UInt8)\n        push!(text, i)\n    end\n    close(file)\n\n    return text\nend","category":"page"},{"location":"man/cipher/#Benchmark","page":"Affine cipher","title":"Benchmark","text":"","category":"section"},{"location":"man/cipher/","page":"Affine cipher","title":"Affine cipher","text":"using StringEncodings, BenchmarkTools\n\ntext = _open(data)\n@btime text = _open($data)\n\ntext_dec = decrypt(text, Ainv, B, M);\n@btime decrypt($text, $Ainv, $B, $M);\n\nresult = decode(text_dec, \"UTF-8\")\n@btime decode($text_dec, \"UTF-8\");\n\n  84.849 ms (34 allocations: 2.00 MiB)\n  8.027 ms (2 allocations: 825.70 KiB)\n  8.538 ms (38083 allocations: 4.29 MiB)","category":"page"},{"location":"man/cipher/#Result","page":"Affine cipher","title":"Result","text":"","category":"section"},{"location":"man/cipher/","page":"Affine cipher","title":"Affine cipher","text":"Cien a침os de soledad \n\nEDITADO POR \"EDICIONES LA CUEVA\" \n\nprintln(result[1:1000])","category":"page"},{"location":"man/cipher/#Multi-threaded-implementation-(CPU)","page":"Affine cipher","title":"Multi-threaded implementation (CPU)","text":"","category":"section"},{"location":"man/cipher/","page":"Affine cipher","title":"Affine cipher","text":"julia> Threads.nthreads()\n 4","category":"page"},{"location":"man/cipher/","page":"Affine cipher","title":"Affine cipher","text":"function decrypt_threaded(message::Vector{<:Integer}, Ainv, B, M)\n    n = length(message)\n    out = similar(message)\n    \n    Threads.@threads for i in 1:n\n        out[i] = decrypt(message[i], Ainv, B, M)\n    end\n    return out\nend\n\nfunction decrypt(x::Integer, Ainv, B, M)\n    y = Ainv * (x - B)\n    return _mod(y, M)\nend","category":"page"},{"location":"man/cipher/#Using-CuArrays-(GPU)","page":"Affine cipher","title":"Using CuArrays (GPU)","text":"","category":"section"},{"location":"man/cipher/#Writing-the-CUDA-kernel","page":"Affine cipher","title":"Writing the CUDA kernel","text":"","category":"section"},{"location":"man/cipher/#Multiple-block-approach","page":"Affine cipher","title":"Multiple-block approach","text":"","category":"section"},{"location":"man/cipher/","page":"Affine cipher","title":"Affine cipher","text":"In this part extend the algorithm to work with multiple blocks of threads such that it can process texts of arbitrary length.","category":"page"},{"location":"","page":"Home","title":"Home","text":"DocTestSetup = :(using GPGPU)","category":"page"},{"location":"#Context","page":"Home","title":"Context","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This repo contains some notes and problem-solving tasks in Julia about General Purpose Programming for Graphics Processing Units (GPGPU).","category":"page"},{"location":"","page":"Home","title":"Home","text":"The assignments material are taken from the 2021 edition of the course GPGPU - Computaci칩n de Prop칩sito General en Unidades de Procesamiento Gr치fico, FING, UdelaR.","category":"page"}]
}
